// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/simproto.proto

#ifndef PROTOBUF_src_2fsimproto_2eproto__INCLUDED
#define PROTOBUF_src_2fsimproto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace simproto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_src_2fsimproto_2eproto();
void protobuf_AssignDesc_src_2fsimproto_2eproto();
void protobuf_ShutdownFile_src_2fsimproto_2eproto();

class Command;
class ApproveRequest;
class ApproveResponse;
class SimConfig;

// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // repeated string args = 2;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // @@protoc_insertion_point(class_scope:simproto.Command)
 private:
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* command_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  friend void  protobuf_AddDesc_src_2fsimproto_2eproto();
  friend void protobuf_AssignDesc_src_2fsimproto_2eproto();
  friend void protobuf_ShutdownFile_src_2fsimproto_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class ApproveRequest : public ::google::protobuf::Message {
 public:
  ApproveRequest();
  virtual ~ApproveRequest();

  ApproveRequest(const ApproveRequest& from);

  inline ApproveRequest& operator=(const ApproveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApproveRequest& default_instance();

  void Swap(ApproveRequest* other);

  // implements Message ----------------------------------------------

  ApproveRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApproveRequest& from);
  void MergeFrom(const ApproveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional .simproto.Command command = 3;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 3;
  inline const ::simproto::Command& command() const;
  inline ::simproto::Command* mutable_command();
  inline ::simproto::Command* release_command();
  inline void set_allocated_command(::simproto::Command* command);

  // optional string justification = 4;
  inline bool has_justification() const;
  inline void clear_justification();
  static const int kJustificationFieldNumber = 4;
  inline const ::std::string& justification() const;
  inline void set_justification(const ::std::string& value);
  inline void set_justification(const char* value);
  inline void set_justification(const char* value, size_t size);
  inline ::std::string* mutable_justification();
  inline ::std::string* release_justification();
  inline void set_allocated_justification(::std::string* justification);

  // @@protoc_insertion_point(class_scope:simproto.ApproveRequest)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_justification();
  inline void clear_has_justification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* host_;
  ::std::string* user_;
  ::simproto::Command* command_;
  ::std::string* justification_;
  friend void  protobuf_AddDesc_src_2fsimproto_2eproto();
  friend void protobuf_AssignDesc_src_2fsimproto_2eproto();
  friend void protobuf_ShutdownFile_src_2fsimproto_2eproto();

  void InitAsDefaultInstance();
  static ApproveRequest* default_instance_;
};
// -------------------------------------------------------------------

class ApproveResponse : public ::google::protobuf::Message {
 public:
  ApproveResponse();
  virtual ~ApproveResponse();

  ApproveResponse(const ApproveResponse& from);

  inline ApproveResponse& operator=(const ApproveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApproveResponse& default_instance();

  void Swap(ApproveResponse* other);

  // implements Message ----------------------------------------------

  ApproveResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApproveResponse& from);
  void MergeFrom(const ApproveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool approved = 1;
  inline bool has_approved() const;
  inline void clear_approved();
  static const int kApprovedFieldNumber = 1;
  inline bool approved() const;
  inline void set_approved(bool value);

  // optional string comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:simproto.ApproveResponse)
 private:
  inline void set_has_approved();
  inline void clear_has_approved();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* comment_;
  bool approved_;
  friend void  protobuf_AddDesc_src_2fsimproto_2eproto();
  friend void protobuf_AssignDesc_src_2fsimproto_2eproto();
  friend void protobuf_ShutdownFile_src_2fsimproto_2eproto();

  void InitAsDefaultInstance();
  static ApproveResponse* default_instance_;
};
// -------------------------------------------------------------------

class SimConfig : public ::google::protobuf::Message {
 public:
  SimConfig();
  virtual ~SimConfig();

  SimConfig(const SimConfig& from);

  inline SimConfig& operator=(const SimConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimConfig& default_instance();

  void Swap(SimConfig* other);

  // implements Message ----------------------------------------------

  SimConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimConfig& from);
  void MergeFrom(const SimConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sock_dir = 1;
  inline bool has_sock_dir() const;
  inline void clear_sock_dir();
  static const int kSockDirFieldNumber = 1;
  inline const ::std::string& sock_dir() const;
  inline void set_sock_dir(const ::std::string& value);
  inline void set_sock_dir(const char* value);
  inline void set_sock_dir(const char* value, size_t size);
  inline ::std::string* mutable_sock_dir();
  inline ::std::string* release_sock_dir();
  inline void set_allocated_sock_dir(::std::string* sock_dir);

  // optional string admin_group = 2;
  inline bool has_admin_group() const;
  inline void clear_admin_group();
  static const int kAdminGroupFieldNumber = 2;
  inline const ::std::string& admin_group() const;
  inline void set_admin_group(const ::std::string& value);
  inline void set_admin_group(const char* value);
  inline void set_admin_group(const char* value, size_t size);
  inline ::std::string* mutable_admin_group();
  inline ::std::string* release_admin_group();
  inline void set_allocated_admin_group(::std::string* admin_group);

  // optional string approve_group = 3;
  inline bool has_approve_group() const;
  inline void clear_approve_group();
  static const int kApproveGroupFieldNumber = 3;
  inline const ::std::string& approve_group() const;
  inline void set_approve_group(const ::std::string& value);
  inline void set_approve_group(const char* value);
  inline void set_approve_group(const char* value, size_t size);
  inline ::std::string* mutable_approve_group();
  inline ::std::string* release_approve_group();
  inline void set_allocated_approve_group(::std::string* approve_group);

  // @@protoc_insertion_point(class_scope:simproto.SimConfig)
 private:
  inline void set_has_sock_dir();
  inline void clear_has_sock_dir();
  inline void set_has_admin_group();
  inline void clear_has_admin_group();
  inline void set_has_approve_group();
  inline void clear_has_approve_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sock_dir_;
  ::std::string* admin_group_;
  ::std::string* approve_group_;
  friend void  protobuf_AddDesc_src_2fsimproto_2eproto();
  friend void protobuf_AssignDesc_src_2fsimproto_2eproto();
  friend void protobuf_ShutdownFile_src_2fsimproto_2eproto();

  void InitAsDefaultInstance();
  static SimConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// required string command = 1;
inline bool Command::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_command() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& Command::command() const {
  // @@protoc_insertion_point(field_get:simproto.Command.command)
  return *command_;
}
inline void Command::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set:simproto.Command.command)
}
inline void Command::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.Command.command)
}
inline void Command::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.Command.command)
}
inline ::std::string* Command::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:simproto.Command.command)
  return command_;
}
inline ::std::string* Command::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Command::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.Command.command)
}

// repeated string args = 2;
inline int Command::args_size() const {
  return args_.size();
}
inline void Command::clear_args() {
  args_.Clear();
}
inline const ::std::string& Command::args(int index) const {
  // @@protoc_insertion_point(field_get:simproto.Command.args)
  return args_.Get(index);
}
inline ::std::string* Command::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:simproto.Command.args)
  return args_.Mutable(index);
}
inline void Command::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:simproto.Command.args)
  args_.Mutable(index)->assign(value);
}
inline void Command::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.Command.args)
}
inline void Command::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.Command.args)
}
inline ::std::string* Command::add_args() {
  return args_.Add();
}
inline void Command::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:simproto.Command.args)
}
inline void Command::add_args(const char* value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:simproto.Command.args)
}
inline void Command::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:simproto.Command.args)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Command::args() const {
  // @@protoc_insertion_point(field_list:simproto.Command.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Command::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:simproto.Command.args)
  return &args_;
}

// -------------------------------------------------------------------

// ApproveRequest

// optional string host = 1;
inline bool ApproveRequest::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApproveRequest::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApproveRequest::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApproveRequest::clear_host() {
  if (host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& ApproveRequest::host() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveRequest.host)
  return *host_;
}
inline void ApproveRequest::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_ = new ::std::string;
  }
  host_->assign(value);
  // @@protoc_insertion_point(field_set:simproto.ApproveRequest.host)
}
inline void ApproveRequest::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_ = new ::std::string;
  }
  host_->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.ApproveRequest.host)
}
inline void ApproveRequest::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.ApproveRequest.host)
}
inline ::std::string* ApproveRequest::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:simproto.ApproveRequest.host)
  return host_;
}
inline ::std::string* ApproveRequest::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApproveRequest::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveRequest.host)
}

// optional string user = 2;
inline bool ApproveRequest::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApproveRequest::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApproveRequest::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApproveRequest::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& ApproveRequest::user() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveRequest.user)
  return *user_;
}
inline void ApproveRequest::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:simproto.ApproveRequest.user)
}
inline void ApproveRequest::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.ApproveRequest.user)
}
inline void ApproveRequest::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.ApproveRequest.user)
}
inline ::std::string* ApproveRequest::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:simproto.ApproveRequest.user)
  return user_;
}
inline ::std::string* ApproveRequest::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApproveRequest::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveRequest.user)
}

// optional .simproto.Command command = 3;
inline bool ApproveRequest::has_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApproveRequest::set_has_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApproveRequest::clear_has_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApproveRequest::clear_command() {
  if (command_ != NULL) command_->::simproto::Command::Clear();
  clear_has_command();
}
inline const ::simproto::Command& ApproveRequest::command() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveRequest.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::simproto::Command* ApproveRequest::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::simproto::Command;
  // @@protoc_insertion_point(field_mutable:simproto.ApproveRequest.command)
  return command_;
}
inline ::simproto::Command* ApproveRequest::release_command() {
  clear_has_command();
  ::simproto::Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void ApproveRequest::set_allocated_command(::simproto::Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveRequest.command)
}

// optional string justification = 4;
inline bool ApproveRequest::has_justification() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApproveRequest::set_has_justification() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApproveRequest::clear_has_justification() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApproveRequest::clear_justification() {
  if (justification_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    justification_->clear();
  }
  clear_has_justification();
}
inline const ::std::string& ApproveRequest::justification() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveRequest.justification)
  return *justification_;
}
inline void ApproveRequest::set_justification(const ::std::string& value) {
  set_has_justification();
  if (justification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    justification_ = new ::std::string;
  }
  justification_->assign(value);
  // @@protoc_insertion_point(field_set:simproto.ApproveRequest.justification)
}
inline void ApproveRequest::set_justification(const char* value) {
  set_has_justification();
  if (justification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    justification_ = new ::std::string;
  }
  justification_->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.ApproveRequest.justification)
}
inline void ApproveRequest::set_justification(const char* value, size_t size) {
  set_has_justification();
  if (justification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    justification_ = new ::std::string;
  }
  justification_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.ApproveRequest.justification)
}
inline ::std::string* ApproveRequest::mutable_justification() {
  set_has_justification();
  if (justification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    justification_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:simproto.ApproveRequest.justification)
  return justification_;
}
inline ::std::string* ApproveRequest::release_justification() {
  clear_has_justification();
  if (justification_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = justification_;
    justification_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApproveRequest::set_allocated_justification(::std::string* justification) {
  if (justification_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete justification_;
  }
  if (justification) {
    set_has_justification();
    justification_ = justification;
  } else {
    clear_has_justification();
    justification_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveRequest.justification)
}

// -------------------------------------------------------------------

// ApproveResponse

// required bool approved = 1;
inline bool ApproveResponse::has_approved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApproveResponse::set_has_approved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApproveResponse::clear_has_approved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApproveResponse::clear_approved() {
  approved_ = false;
  clear_has_approved();
}
inline bool ApproveResponse::approved() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveResponse.approved)
  return approved_;
}
inline void ApproveResponse::set_approved(bool value) {
  set_has_approved();
  approved_ = value;
  // @@protoc_insertion_point(field_set:simproto.ApproveResponse.approved)
}

// optional string comment = 2;
inline bool ApproveResponse::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApproveResponse::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApproveResponse::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApproveResponse::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ApproveResponse::comment() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveResponse.comment)
  return *comment_;
}
inline void ApproveResponse::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:simproto.ApproveResponse.comment)
}
inline void ApproveResponse::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.ApproveResponse.comment)
}
inline void ApproveResponse::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.ApproveResponse.comment)
}
inline ::std::string* ApproveResponse::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:simproto.ApproveResponse.comment)
  return comment_;
}
inline ::std::string* ApproveResponse::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApproveResponse::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveResponse.comment)
}

// -------------------------------------------------------------------

// SimConfig

// required string sock_dir = 1;
inline bool SimConfig::has_sock_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimConfig::set_has_sock_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimConfig::clear_has_sock_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimConfig::clear_sock_dir() {
  if (sock_dir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sock_dir_->clear();
  }
  clear_has_sock_dir();
}
inline const ::std::string& SimConfig::sock_dir() const {
  // @@protoc_insertion_point(field_get:simproto.SimConfig.sock_dir)
  return *sock_dir_;
}
inline void SimConfig::set_sock_dir(const ::std::string& value) {
  set_has_sock_dir();
  if (sock_dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sock_dir_ = new ::std::string;
  }
  sock_dir_->assign(value);
  // @@protoc_insertion_point(field_set:simproto.SimConfig.sock_dir)
}
inline void SimConfig::set_sock_dir(const char* value) {
  set_has_sock_dir();
  if (sock_dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sock_dir_ = new ::std::string;
  }
  sock_dir_->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.SimConfig.sock_dir)
}
inline void SimConfig::set_sock_dir(const char* value, size_t size) {
  set_has_sock_dir();
  if (sock_dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sock_dir_ = new ::std::string;
  }
  sock_dir_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.SimConfig.sock_dir)
}
inline ::std::string* SimConfig::mutable_sock_dir() {
  set_has_sock_dir();
  if (sock_dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sock_dir_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:simproto.SimConfig.sock_dir)
  return sock_dir_;
}
inline ::std::string* SimConfig::release_sock_dir() {
  clear_has_sock_dir();
  if (sock_dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sock_dir_;
    sock_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SimConfig::set_allocated_sock_dir(::std::string* sock_dir) {
  if (sock_dir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sock_dir_;
  }
  if (sock_dir) {
    set_has_sock_dir();
    sock_dir_ = sock_dir;
  } else {
    clear_has_sock_dir();
    sock_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.SimConfig.sock_dir)
}

// optional string admin_group = 2;
inline bool SimConfig::has_admin_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimConfig::set_has_admin_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimConfig::clear_has_admin_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimConfig::clear_admin_group() {
  if (admin_group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_group_->clear();
  }
  clear_has_admin_group();
}
inline const ::std::string& SimConfig::admin_group() const {
  // @@protoc_insertion_point(field_get:simproto.SimConfig.admin_group)
  return *admin_group_;
}
inline void SimConfig::set_admin_group(const ::std::string& value) {
  set_has_admin_group();
  if (admin_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_group_ = new ::std::string;
  }
  admin_group_->assign(value);
  // @@protoc_insertion_point(field_set:simproto.SimConfig.admin_group)
}
inline void SimConfig::set_admin_group(const char* value) {
  set_has_admin_group();
  if (admin_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_group_ = new ::std::string;
  }
  admin_group_->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.SimConfig.admin_group)
}
inline void SimConfig::set_admin_group(const char* value, size_t size) {
  set_has_admin_group();
  if (admin_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_group_ = new ::std::string;
  }
  admin_group_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.SimConfig.admin_group)
}
inline ::std::string* SimConfig::mutable_admin_group() {
  set_has_admin_group();
  if (admin_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    admin_group_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:simproto.SimConfig.admin_group)
  return admin_group_;
}
inline ::std::string* SimConfig::release_admin_group() {
  clear_has_admin_group();
  if (admin_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = admin_group_;
    admin_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SimConfig::set_allocated_admin_group(::std::string* admin_group) {
  if (admin_group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete admin_group_;
  }
  if (admin_group) {
    set_has_admin_group();
    admin_group_ = admin_group;
  } else {
    clear_has_admin_group();
    admin_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.SimConfig.admin_group)
}

// optional string approve_group = 3;
inline bool SimConfig::has_approve_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimConfig::set_has_approve_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimConfig::clear_has_approve_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimConfig::clear_approve_group() {
  if (approve_group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    approve_group_->clear();
  }
  clear_has_approve_group();
}
inline const ::std::string& SimConfig::approve_group() const {
  // @@protoc_insertion_point(field_get:simproto.SimConfig.approve_group)
  return *approve_group_;
}
inline void SimConfig::set_approve_group(const ::std::string& value) {
  set_has_approve_group();
  if (approve_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    approve_group_ = new ::std::string;
  }
  approve_group_->assign(value);
  // @@protoc_insertion_point(field_set:simproto.SimConfig.approve_group)
}
inline void SimConfig::set_approve_group(const char* value) {
  set_has_approve_group();
  if (approve_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    approve_group_ = new ::std::string;
  }
  approve_group_->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.SimConfig.approve_group)
}
inline void SimConfig::set_approve_group(const char* value, size_t size) {
  set_has_approve_group();
  if (approve_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    approve_group_ = new ::std::string;
  }
  approve_group_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.SimConfig.approve_group)
}
inline ::std::string* SimConfig::mutable_approve_group() {
  set_has_approve_group();
  if (approve_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    approve_group_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:simproto.SimConfig.approve_group)
  return approve_group_;
}
inline ::std::string* SimConfig::release_approve_group() {
  clear_has_approve_group();
  if (approve_group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = approve_group_;
    approve_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SimConfig::set_allocated_approve_group(::std::string* approve_group) {
  if (approve_group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete approve_group_;
  }
  if (approve_group) {
    set_has_approve_group();
    approve_group_ = approve_group;
  } else {
    clear_has_approve_group();
    approve_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:simproto.SimConfig.approve_group)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace simproto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_src_2fsimproto_2eproto__INCLUDED
