// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/simproto.proto

#ifndef PROTOBUF_INCLUDED_src_2fsimproto_2eproto
#define PROTOBUF_INCLUDED_src_2fsimproto_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_src_2fsimproto_2eproto 

namespace protobuf_src_2fsimproto_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_src_2fsimproto_2eproto
namespace simproto {
class ApproveRequest;
class ApproveRequestDefaultTypeInternal;
extern ApproveRequestDefaultTypeInternal _ApproveRequest_default_instance_;
class ApproveResponse;
class ApproveResponseDefaultTypeInternal;
extern ApproveResponseDefaultTypeInternal _ApproveResponse_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class SimConfig;
class SimConfigDefaultTypeInternal;
extern SimConfigDefaultTypeInternal _SimConfig_default_instance_;
}  // namespace simproto
namespace google {
namespace protobuf {
template<> ::simproto::ApproveRequest* Arena::CreateMaybeMessage<::simproto::ApproveRequest>(Arena*);
template<> ::simproto::ApproveResponse* Arena::CreateMaybeMessage<::simproto::ApproveResponse>(Arena*);
template<> ::simproto::Command* Arena::CreateMaybeMessage<::simproto::Command>(Arena*);
template<> ::simproto::SimConfig* Arena::CreateMaybeMessage<::simproto::SimConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace simproto {

// ===================================================================

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:simproto.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(NULL);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string args = 3;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 3;
  const ::std::string& args(int index) const;
  ::std::string* mutable_args(int index);
  void set_args(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_args(int index, ::std::string&& value);
  #endif
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  ::std::string* add_args();
  void add_args(const ::std::string& value);
  #if LANG_CXX11
  void add_args(::std::string&& value);
  #endif
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // required string cwd = 1;
  bool has_cwd() const;
  void clear_cwd();
  static const int kCwdFieldNumber = 1;
  const ::std::string& cwd() const;
  void set_cwd(const ::std::string& value);
  #if LANG_CXX11
  void set_cwd(::std::string&& value);
  #endif
  void set_cwd(const char* value);
  void set_cwd(const char* value, size_t size);
  ::std::string* mutable_cwd();
  ::std::string* release_cwd();
  void set_allocated_cwd(::std::string* cwd);

  // required string command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // @@protoc_insertion_point(class_scope:simproto.Command)
 private:
  void set_has_cwd();
  void clear_has_cwd();
  void set_has_command();
  void clear_has_command();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::internal::ArenaStringPtr cwd_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  friend struct ::protobuf_src_2fsimproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApproveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:simproto.ApproveRequest) */ {
 public:
  ApproveRequest();
  virtual ~ApproveRequest();

  ApproveRequest(const ApproveRequest& from);

  inline ApproveRequest& operator=(const ApproveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApproveRequest(ApproveRequest&& from) noexcept
    : ApproveRequest() {
    *this = ::std::move(from);
  }

  inline ApproveRequest& operator=(ApproveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApproveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApproveRequest* internal_default_instance() {
    return reinterpret_cast<const ApproveRequest*>(
               &_ApproveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ApproveRequest* other);
  friend void swap(ApproveRequest& a, ApproveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApproveRequest* New() const final {
    return CreateMaybeMessage<ApproveRequest>(NULL);
  }

  ApproveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApproveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ApproveRequest& from);
  void MergeFrom(const ApproveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApproveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string host = 1;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // optional string user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string justification = 4;
  bool has_justification() const;
  void clear_justification();
  static const int kJustificationFieldNumber = 4;
  const ::std::string& justification() const;
  void set_justification(const ::std::string& value);
  #if LANG_CXX11
  void set_justification(::std::string&& value);
  #endif
  void set_justification(const char* value);
  void set_justification(const char* value, size_t size);
  ::std::string* mutable_justification();
  ::std::string* release_justification();
  void set_allocated_justification(::std::string* justification);

  // optional .simproto.Command command = 3;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 3;
  private:
  const ::simproto::Command& _internal_command() const;
  public:
  const ::simproto::Command& command() const;
  ::simproto::Command* release_command();
  ::simproto::Command* mutable_command();
  void set_allocated_command(::simproto::Command* command);

  // @@protoc_insertion_point(class_scope:simproto.ApproveRequest)
 private:
  void set_has_host();
  void clear_has_host();
  void set_has_user();
  void clear_has_user();
  void set_has_command();
  void clear_has_command();
  void set_has_justification();
  void clear_has_justification();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr justification_;
  ::simproto::Command* command_;
  friend struct ::protobuf_src_2fsimproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApproveResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:simproto.ApproveResponse) */ {
 public:
  ApproveResponse();
  virtual ~ApproveResponse();

  ApproveResponse(const ApproveResponse& from);

  inline ApproveResponse& operator=(const ApproveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApproveResponse(ApproveResponse&& from) noexcept
    : ApproveResponse() {
    *this = ::std::move(from);
  }

  inline ApproveResponse& operator=(ApproveResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApproveResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApproveResponse* internal_default_instance() {
    return reinterpret_cast<const ApproveResponse*>(
               &_ApproveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ApproveResponse* other);
  friend void swap(ApproveResponse& a, ApproveResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApproveResponse* New() const final {
    return CreateMaybeMessage<ApproveResponse>(NULL);
  }

  ApproveResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApproveResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ApproveResponse& from);
  void MergeFrom(const ApproveResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApproveResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // required bool approved = 1;
  bool has_approved() const;
  void clear_approved();
  static const int kApprovedFieldNumber = 1;
  bool approved() const;
  void set_approved(bool value);

  // @@protoc_insertion_point(class_scope:simproto.ApproveResponse)
 private:
  void set_has_approved();
  void clear_has_approved();
  void set_has_comment();
  void clear_has_comment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool approved_;
  friend struct ::protobuf_src_2fsimproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:simproto.SimConfig) */ {
 public:
  SimConfig();
  virtual ~SimConfig();

  SimConfig(const SimConfig& from);

  inline SimConfig& operator=(const SimConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimConfig(SimConfig&& from) noexcept
    : SimConfig() {
    *this = ::std::move(from);
  }

  inline SimConfig& operator=(SimConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimConfig* internal_default_instance() {
    return reinterpret_cast<const SimConfig*>(
               &_SimConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SimConfig* other);
  friend void swap(SimConfig& a, SimConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimConfig* New() const final {
    return CreateMaybeMessage<SimConfig>(NULL);
  }

  SimConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SimConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SimConfig& from);
  void MergeFrom(const SimConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sock_dir = 1;
  bool has_sock_dir() const;
  void clear_sock_dir();
  static const int kSockDirFieldNumber = 1;
  const ::std::string& sock_dir() const;
  void set_sock_dir(const ::std::string& value);
  #if LANG_CXX11
  void set_sock_dir(::std::string&& value);
  #endif
  void set_sock_dir(const char* value);
  void set_sock_dir(const char* value, size_t size);
  ::std::string* mutable_sock_dir();
  ::std::string* release_sock_dir();
  void set_allocated_sock_dir(::std::string* sock_dir);

  // optional string admin_group = 2;
  bool has_admin_group() const;
  void clear_admin_group();
  static const int kAdminGroupFieldNumber = 2;
  const ::std::string& admin_group() const;
  void set_admin_group(const ::std::string& value);
  #if LANG_CXX11
  void set_admin_group(::std::string&& value);
  #endif
  void set_admin_group(const char* value);
  void set_admin_group(const char* value, size_t size);
  ::std::string* mutable_admin_group();
  ::std::string* release_admin_group();
  void set_allocated_admin_group(::std::string* admin_group);

  // optional string approve_group = 3;
  bool has_approve_group() const;
  void clear_approve_group();
  static const int kApproveGroupFieldNumber = 3;
  const ::std::string& approve_group() const;
  void set_approve_group(const ::std::string& value);
  #if LANG_CXX11
  void set_approve_group(::std::string&& value);
  #endif
  void set_approve_group(const char* value);
  void set_approve_group(const char* value, size_t size);
  ::std::string* mutable_approve_group();
  ::std::string* release_approve_group();
  void set_allocated_approve_group(::std::string* approve_group);

  // @@protoc_insertion_point(class_scope:simproto.SimConfig)
 private:
  void set_has_sock_dir();
  void clear_has_sock_dir();
  void set_has_admin_group();
  void clear_has_admin_group();
  void set_has_approve_group();
  void clear_has_approve_group();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sock_dir_;
  ::google::protobuf::internal::ArenaStringPtr admin_group_;
  ::google::protobuf::internal::ArenaStringPtr approve_group_;
  friend struct ::protobuf_src_2fsimproto_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Command

// required string cwd = 1;
inline bool Command::has_cwd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_cwd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_cwd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_cwd() {
  cwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cwd();
}
inline const ::std::string& Command::cwd() const {
  // @@protoc_insertion_point(field_get:simproto.Command.cwd)
  return cwd_.GetNoArena();
}
inline void Command::set_cwd(const ::std::string& value) {
  set_has_cwd();
  cwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.Command.cwd)
}
#if LANG_CXX11
inline void Command::set_cwd(::std::string&& value) {
  set_has_cwd();
  cwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.Command.cwd)
}
#endif
inline void Command::set_cwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cwd();
  cwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.Command.cwd)
}
inline void Command::set_cwd(const char* value, size_t size) {
  set_has_cwd();
  cwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.Command.cwd)
}
inline ::std::string* Command::mutable_cwd() {
  set_has_cwd();
  // @@protoc_insertion_point(field_mutable:simproto.Command.cwd)
  return cwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_cwd() {
  // @@protoc_insertion_point(field_release:simproto.Command.cwd)
  if (!has_cwd()) {
    return NULL;
  }
  clear_has_cwd();
  return cwd_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_allocated_cwd(::std::string* cwd) {
  if (cwd != NULL) {
    set_has_cwd();
  } else {
    clear_has_cwd();
  }
  cwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cwd);
  // @@protoc_insertion_point(field_set_allocated:simproto.Command.cwd)
}

// required string command = 2;
inline bool Command::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_command();
}
inline const ::std::string& Command::command() const {
  // @@protoc_insertion_point(field_get:simproto.Command.command)
  return command_.GetNoArena();
}
inline void Command::set_command(const ::std::string& value) {
  set_has_command();
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.Command.command)
}
#if LANG_CXX11
inline void Command::set_command(::std::string&& value) {
  set_has_command();
  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.Command.command)
}
#endif
inline void Command::set_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_command();
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.Command.command)
}
inline void Command::set_command(const char* value, size_t size) {
  set_has_command();
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.Command.command)
}
inline ::std::string* Command::mutable_command() {
  set_has_command();
  // @@protoc_insertion_point(field_mutable:simproto.Command.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_command() {
  // @@protoc_insertion_point(field_release:simproto.Command.command)
  if (!has_command()) {
    return NULL;
  }
  clear_has_command();
  return command_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_allocated_command(::std::string* command) {
  if (command != NULL) {
    set_has_command();
  } else {
    clear_has_command();
  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:simproto.Command.command)
}

// repeated string args = 3;
inline int Command::args_size() const {
  return args_.size();
}
inline void Command::clear_args() {
  args_.Clear();
}
inline const ::std::string& Command::args(int index) const {
  // @@protoc_insertion_point(field_get:simproto.Command.args)
  return args_.Get(index);
}
inline ::std::string* Command::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:simproto.Command.args)
  return args_.Mutable(index);
}
inline void Command::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:simproto.Command.args)
  args_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Command::set_args(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:simproto.Command.args)
  args_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Command::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:simproto.Command.args)
}
inline void Command::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:simproto.Command.args)
}
inline ::std::string* Command::add_args() {
  // @@protoc_insertion_point(field_add_mutable:simproto.Command.args)
  return args_.Add();
}
inline void Command::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:simproto.Command.args)
}
#if LANG_CXX11
inline void Command::add_args(::std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:simproto.Command.args)
}
#endif
inline void Command::add_args(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:simproto.Command.args)
}
inline void Command::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:simproto.Command.args)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Command::args() const {
  // @@protoc_insertion_point(field_list:simproto.Command.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Command::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:simproto.Command.args)
  return &args_;
}

// -------------------------------------------------------------------

// ApproveRequest

// optional string host = 1;
inline bool ApproveRequest::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApproveRequest::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApproveRequest::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApproveRequest::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& ApproveRequest::host() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveRequest.host)
  return host_.GetNoArena();
}
inline void ApproveRequest::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.ApproveRequest.host)
}
#if LANG_CXX11
inline void ApproveRequest::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.ApproveRequest.host)
}
#endif
inline void ApproveRequest::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.ApproveRequest.host)
}
inline void ApproveRequest::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.ApproveRequest.host)
}
inline ::std::string* ApproveRequest::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:simproto.ApproveRequest.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApproveRequest::release_host() {
  // @@protoc_insertion_point(field_release:simproto.ApproveRequest.host)
  if (!has_host()) {
    return NULL;
  }
  clear_has_host();
  return host_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApproveRequest::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveRequest.host)
}

// optional string user = 2;
inline bool ApproveRequest::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApproveRequest::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApproveRequest::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApproveRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& ApproveRequest::user() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveRequest.user)
  return user_.GetNoArena();
}
inline void ApproveRequest::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.ApproveRequest.user)
}
#if LANG_CXX11
inline void ApproveRequest::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.ApproveRequest.user)
}
#endif
inline void ApproveRequest::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.ApproveRequest.user)
}
inline void ApproveRequest::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.ApproveRequest.user)
}
inline ::std::string* ApproveRequest::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:simproto.ApproveRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApproveRequest::release_user() {
  // @@protoc_insertion_point(field_release:simproto.ApproveRequest.user)
  if (!has_user()) {
    return NULL;
  }
  clear_has_user();
  return user_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApproveRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveRequest.user)
}

// optional .simproto.Command command = 3;
inline bool ApproveRequest::has_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApproveRequest::set_has_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApproveRequest::clear_has_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApproveRequest::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::simproto::Command& ApproveRequest::_internal_command() const {
  return *command_;
}
inline const ::simproto::Command& ApproveRequest::command() const {
  const ::simproto::Command* p = command_;
  // @@protoc_insertion_point(field_get:simproto.ApproveRequest.command)
  return p != NULL ? *p : *reinterpret_cast<const ::simproto::Command*>(
      &::simproto::_Command_default_instance_);
}
inline ::simproto::Command* ApproveRequest::release_command() {
  // @@protoc_insertion_point(field_release:simproto.ApproveRequest.command)
  clear_has_command();
  ::simproto::Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::simproto::Command* ApproveRequest::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    auto* p = CreateMaybeMessage<::simproto::Command>(GetArenaNoVirtual());
    command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:simproto.ApproveRequest.command)
  return command_;
}
inline void ApproveRequest::set_allocated_command(::simproto::Command* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveRequest.command)
}

// optional string justification = 4;
inline bool ApproveRequest::has_justification() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApproveRequest::set_has_justification() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApproveRequest::clear_has_justification() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApproveRequest::clear_justification() {
  justification_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_justification();
}
inline const ::std::string& ApproveRequest::justification() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveRequest.justification)
  return justification_.GetNoArena();
}
inline void ApproveRequest::set_justification(const ::std::string& value) {
  set_has_justification();
  justification_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.ApproveRequest.justification)
}
#if LANG_CXX11
inline void ApproveRequest::set_justification(::std::string&& value) {
  set_has_justification();
  justification_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.ApproveRequest.justification)
}
#endif
inline void ApproveRequest::set_justification(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_justification();
  justification_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.ApproveRequest.justification)
}
inline void ApproveRequest::set_justification(const char* value, size_t size) {
  set_has_justification();
  justification_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.ApproveRequest.justification)
}
inline ::std::string* ApproveRequest::mutable_justification() {
  set_has_justification();
  // @@protoc_insertion_point(field_mutable:simproto.ApproveRequest.justification)
  return justification_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApproveRequest::release_justification() {
  // @@protoc_insertion_point(field_release:simproto.ApproveRequest.justification)
  if (!has_justification()) {
    return NULL;
  }
  clear_has_justification();
  return justification_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApproveRequest::set_allocated_justification(::std::string* justification) {
  if (justification != NULL) {
    set_has_justification();
  } else {
    clear_has_justification();
  }
  justification_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), justification);
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveRequest.justification)
}

// -------------------------------------------------------------------

// ApproveResponse

// required bool approved = 1;
inline bool ApproveResponse::has_approved() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApproveResponse::set_has_approved() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApproveResponse::clear_has_approved() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApproveResponse::clear_approved() {
  approved_ = false;
  clear_has_approved();
}
inline bool ApproveResponse::approved() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveResponse.approved)
  return approved_;
}
inline void ApproveResponse::set_approved(bool value) {
  set_has_approved();
  approved_ = value;
  // @@protoc_insertion_point(field_set:simproto.ApproveResponse.approved)
}

// optional string comment = 2;
inline bool ApproveResponse::has_comment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApproveResponse::set_has_comment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApproveResponse::clear_has_comment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApproveResponse::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& ApproveResponse::comment() const {
  // @@protoc_insertion_point(field_get:simproto.ApproveResponse.comment)
  return comment_.GetNoArena();
}
inline void ApproveResponse::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.ApproveResponse.comment)
}
#if LANG_CXX11
inline void ApproveResponse::set_comment(::std::string&& value) {
  set_has_comment();
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.ApproveResponse.comment)
}
#endif
inline void ApproveResponse::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.ApproveResponse.comment)
}
inline void ApproveResponse::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.ApproveResponse.comment)
}
inline ::std::string* ApproveResponse::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:simproto.ApproveResponse.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApproveResponse::release_comment() {
  // @@protoc_insertion_point(field_release:simproto.ApproveResponse.comment)
  if (!has_comment()) {
    return NULL;
  }
  clear_has_comment();
  return comment_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApproveResponse::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:simproto.ApproveResponse.comment)
}

// -------------------------------------------------------------------

// SimConfig

// required string sock_dir = 1;
inline bool SimConfig::has_sock_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimConfig::set_has_sock_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimConfig::clear_has_sock_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimConfig::clear_sock_dir() {
  sock_dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sock_dir();
}
inline const ::std::string& SimConfig::sock_dir() const {
  // @@protoc_insertion_point(field_get:simproto.SimConfig.sock_dir)
  return sock_dir_.GetNoArena();
}
inline void SimConfig::set_sock_dir(const ::std::string& value) {
  set_has_sock_dir();
  sock_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.SimConfig.sock_dir)
}
#if LANG_CXX11
inline void SimConfig::set_sock_dir(::std::string&& value) {
  set_has_sock_dir();
  sock_dir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.SimConfig.sock_dir)
}
#endif
inline void SimConfig::set_sock_dir(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sock_dir();
  sock_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.SimConfig.sock_dir)
}
inline void SimConfig::set_sock_dir(const char* value, size_t size) {
  set_has_sock_dir();
  sock_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.SimConfig.sock_dir)
}
inline ::std::string* SimConfig::mutable_sock_dir() {
  set_has_sock_dir();
  // @@protoc_insertion_point(field_mutable:simproto.SimConfig.sock_dir)
  return sock_dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimConfig::release_sock_dir() {
  // @@protoc_insertion_point(field_release:simproto.SimConfig.sock_dir)
  if (!has_sock_dir()) {
    return NULL;
  }
  clear_has_sock_dir();
  return sock_dir_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimConfig::set_allocated_sock_dir(::std::string* sock_dir) {
  if (sock_dir != NULL) {
    set_has_sock_dir();
  } else {
    clear_has_sock_dir();
  }
  sock_dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sock_dir);
  // @@protoc_insertion_point(field_set_allocated:simproto.SimConfig.sock_dir)
}

// optional string admin_group = 2;
inline bool SimConfig::has_admin_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimConfig::set_has_admin_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimConfig::clear_has_admin_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimConfig::clear_admin_group() {
  admin_group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_admin_group();
}
inline const ::std::string& SimConfig::admin_group() const {
  // @@protoc_insertion_point(field_get:simproto.SimConfig.admin_group)
  return admin_group_.GetNoArena();
}
inline void SimConfig::set_admin_group(const ::std::string& value) {
  set_has_admin_group();
  admin_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.SimConfig.admin_group)
}
#if LANG_CXX11
inline void SimConfig::set_admin_group(::std::string&& value) {
  set_has_admin_group();
  admin_group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.SimConfig.admin_group)
}
#endif
inline void SimConfig::set_admin_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_admin_group();
  admin_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.SimConfig.admin_group)
}
inline void SimConfig::set_admin_group(const char* value, size_t size) {
  set_has_admin_group();
  admin_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.SimConfig.admin_group)
}
inline ::std::string* SimConfig::mutable_admin_group() {
  set_has_admin_group();
  // @@protoc_insertion_point(field_mutable:simproto.SimConfig.admin_group)
  return admin_group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimConfig::release_admin_group() {
  // @@protoc_insertion_point(field_release:simproto.SimConfig.admin_group)
  if (!has_admin_group()) {
    return NULL;
  }
  clear_has_admin_group();
  return admin_group_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimConfig::set_allocated_admin_group(::std::string* admin_group) {
  if (admin_group != NULL) {
    set_has_admin_group();
  } else {
    clear_has_admin_group();
  }
  admin_group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), admin_group);
  // @@protoc_insertion_point(field_set_allocated:simproto.SimConfig.admin_group)
}

// optional string approve_group = 3;
inline bool SimConfig::has_approve_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimConfig::set_has_approve_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimConfig::clear_has_approve_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimConfig::clear_approve_group() {
  approve_group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_approve_group();
}
inline const ::std::string& SimConfig::approve_group() const {
  // @@protoc_insertion_point(field_get:simproto.SimConfig.approve_group)
  return approve_group_.GetNoArena();
}
inline void SimConfig::set_approve_group(const ::std::string& value) {
  set_has_approve_group();
  approve_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:simproto.SimConfig.approve_group)
}
#if LANG_CXX11
inline void SimConfig::set_approve_group(::std::string&& value) {
  set_has_approve_group();
  approve_group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:simproto.SimConfig.approve_group)
}
#endif
inline void SimConfig::set_approve_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_approve_group();
  approve_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:simproto.SimConfig.approve_group)
}
inline void SimConfig::set_approve_group(const char* value, size_t size) {
  set_has_approve_group();
  approve_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:simproto.SimConfig.approve_group)
}
inline ::std::string* SimConfig::mutable_approve_group() {
  set_has_approve_group();
  // @@protoc_insertion_point(field_mutable:simproto.SimConfig.approve_group)
  return approve_group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimConfig::release_approve_group() {
  // @@protoc_insertion_point(field_release:simproto.SimConfig.approve_group)
  if (!has_approve_group()) {
    return NULL;
  }
  clear_has_approve_group();
  return approve_group_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimConfig::set_allocated_approve_group(::std::string* approve_group) {
  if (approve_group != NULL) {
    set_has_approve_group();
  } else {
    clear_has_approve_group();
  }
  approve_group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), approve_group);
  // @@protoc_insertion_point(field_set_allocated:simproto.SimConfig.approve_group)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace simproto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_src_2fsimproto_2eproto
